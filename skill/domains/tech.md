# Domain: Technology

## Source Trust Hierarchy

**Tier 1 - Primary Sources (Highest Trust)**
- Official documentation from the project/product itself
- Original research papers, whitepapers, RFCs
- Official announcements from maintainers/creators
- Source code and changelogs
- GitHub releases and official project pages

**Tier 2 - Verified Secondary Sources (High Trust)**
- Established technical publications with named authors and editorial standards
- Conference talks and presentations by practitioners
- Core maintainer blog posts and technical writeups
- Well-researched comparison articles from reputable tech sites

**Tier 3 - Community Sources (Moderate Trust - Verify Claims)**
- Stack Overflow answers (check vote count, age, accepted status)
- GitHub discussions and issues (direct from users/maintainers)
- Developer blog posts (check author credentials, date, citations)
- Tutorial sites (cross-reference with official docs)
- Hacker News discussions (good for signal on adoption, problems)

**Tier 4 - Use With Caution**
- SEO-optimized "listicle" articles ("Top 10 best...")
- Content farms and aggregator sites
- Anonymous or unattributed content
- Outdated content (>2 years for fast-moving tech)
- AI-generated summaries without citations

## Domain-Specific Evaluation

### Currency Matters
- Technology moves fast - prefer sources < 1-2 years old
- Check version numbers - advice for v1 may not apply to v3
- Look for "last updated" dates, especially in docs

### Authority Signals
- URL signals: official project domains, `.dev`, recognized tech companies
- Author: maintainer, contributor, known practitioner vs. content writer
- Evidence of real usage: code examples, benchmarks, production experience

### Practical Validation
- Look for: benchmarks, code examples, production use cases
- Be skeptical of: theoretical comparisons without real-world testing
- Value: "I tried this in production and here's what happened"

## Clarifying Questions (Examples)

When researching tech topics, consider asking about:
- Use case (read-only vs. write-heavy, development vs. production)
- Environment constraints (cloud, on-prem, specific platforms)
- Scale requirements (hobby project vs. enterprise)
- Integration needs (what else does this need to work with)
- Experience level (beginner-friendly vs. power-user features)
